---
title: CAS
category: 锁
---
- 什么是CAS?
Compare and swap,比较并交换.一种乐观锁的实现
其机制就是在要修改资源时会先对资源进行一个检验,是否与预期值相同,如果相同则修改,如果不同则不进行操作 
java中Atomic包中很多类就使用了CAS,调用Unsafe类实现

- java的CAS是怎么实现的
Java的CAS是通过Unsafe类中的compareAndSwapInt(),compareAndSwapLong()等方法实现.其底层是通过JNI实现,通过调用C语言来调用CPU底层的指令来实现的.

- 现代计算机动不动就是上百核心,系统底层如何保证的多线程下的线程安全
系统底层进行CAS操作时,会先判定是否是多核系统,如果是则给总线加锁,

- 什么是Unsafe
Unsafe是java提供的一个类,提供了很多的底层操作,包括:CAS, 线程, 内存等操作,不建议在生产环境中使用.尽管Unsafe类的功能十分强大,但是其具有不安全性,且属于内部API,更推荐使用高层次的包来实现相关功能  

- CAS的问题
1. ABA问题
2. 超高并发下一直重试不能操作成功
3. 只能保证一个变量的原子操作,如果想保证多个变量的,可能得构造一个类,然后使用AtomicReference控制

- 什么是ABA问题
以三个线程为例,均要对x进行操作:
线程A预期值为x,想修改为y
线程B预期值为x,想修改为y
线程C预期值为y,想修改为x

然后线程A成功执行,值改为y,然后线程C进行了修改,将值修改为了x,最后线程B也能成功执行,又将值改为了y.  
这就是ABA问题,其实实际值并不是预期的,但他碰巧几次操作后与预期值相同,导致不该执行的操作执行了

- 如何解决ABA问题
为数据添加版本号,并且版本号自增,递增的版本号就不会出现ABA现象了. java提供了AtomicStampedReference可以使用  

- 乐观锁一定比悲观锁高效嘛
不一定.在极高的并发环境下,乐观锁的性能可能比悲观锁更差.  
原因: 在极高的并发环境下,可能导致CAS一直失败导致操作失败,直接使用悲观锁可能同时操作的线程少,但几乎能一次成功  
