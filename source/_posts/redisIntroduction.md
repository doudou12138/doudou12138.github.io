---
title: redis概述
category: redis
--- 
- redis为什么快
1. redis是基于内存,redis的操作在内存中进行,内存操作效率比磁盘的效率高得多
2. redis是采用单线程模型(事件处理采用单线程),没有多线程之间切换的上下文切换成本
3. redis采用IO多路复用模型,
4. redis的有着丰富的数据结构且设计巧妙,效率高

- redis和memcached的区别
redis和memcached都基于内存,且可以做缓存但有着以下区别:
1. redis支持更丰富的数据类型(string, set, zset, list, hash, geo, bitmap, hyperloglog);而memcached只支持key-value
2. redis有持久化功能(aof,rdb);而memcached没有,服务宕机了数据就丢失了
3. redis原生支持集群
4. redis支持订阅模型,lua脚本,事务等功能,而memcached不支持
5. memcached的过期策略是惰性删除,而redis同时使用了惰性删除和定期删除

- redis的过期策略
惰性删除 + 定期删除

- redis的淘汰策略
1. Allkeys-random
2. Allkeys-lru
3. 

- redis中过期时间和key在一起吗
不在.  
```
typedef struct redisDb{
    dict *dict;  
    dict *expires;
    ....
}
```
其中dict是保存键值对的,expires是保存key和对应的过期时间long long类型  

- 什么是IO多路复用
当多个客户端与服务端建立连接时,每个连接(socket)都会生成一个fd(文件描述符,毕竟linux中一切皆文件).正常的每个连接都用一个线程来监听,而IO多路复用则是使用一个线程来监听所有的连接对应的fd.  
redis中的多路复用则使用一个线程来监听客户端连接的多个fd,然后将对应的事件交给事件处理器.
他有select, poll, epoll等实现方式

- select, poll, epoll的区别
select,poll,epoll都是IO多路复用的实现方式.其中:
1. select方式线程会轮询所有的fd(所以fd越高,性能越低,线性降低),并检测是否有事件.并且select最多只支持1024个fd
2. poll方式线程也是轮询fd,但是**没有最大文件描述符数量的限制**,因其基于链表存储
3. epoll方式不轮询fd,而是为fd提供一个回调,再准备好后就通过回调将事件放入**就绪队列**,线程只用判断就绪队列是否为空,比轮询fd快得多 O(n)->O(1)

- 为什么select的文件描述符限制是1024:
因为select监听的文件描述符是使用数组记录的,其中数组的长度也是由一个宏定义的为1024;如果超过了1024,则可能出现数组越界带来的一些异常问题

- 为什么lua脚本能保证原子性
redis是单线程模型,并且它会把lua脚本当成一个整体来看待.所以一次只会有一个lua脚本执行,并且lua脚本的执行不会被其他操作中断

- 什么是缓存热点
缓存热点指redis中的热点数据,热点数据在过期时可能造成缓存击穿的问题. 在不过期的时候也可能造成问题,下面聊聊这个:
对于一个redis集群,8台机器吧,如果50万请求均匀地打到这些机器上,没有问题,但是如果其中30万都是针对某一个热点数据,那岂不**30万的qps就打到一台机器上**了,然后该机器崩了.接着缓存中就没有了该数据,30万的qps去数据库中查询(做了缓存击穿的防护就还行),接着把这个热点数据放到另一台redis机器上,又一台机器崩了,最后所有的机器都崩了. 相当恐怖的后果
解决方案:
1. 引入流式计算系统Strom/Spark Streaming/Flink(流式计算系统的特性它的计算过程不会被打崩)进行热点数据感知,判断为热点数据则将其写入比如Zookeeper中,然后系统集群感知到热点缓存,并将这个缓存放到本地缓存中,那么后面热点数据的qps就被均衡到各个系统服务机器上了
2. 限流熔断保护:
即在每个系统实例根据缓存集群的负载能力,限流,控制系统实例对缓存集群的qps,反正一定把缓存集群保住

- 如何实现本地缓存的一致性
本地缓存的一致性是使用本地缓存面临的最大的问题,其解决方法有以下:
1. 为本地缓存添加一个过期时间,过期时间由对数据一致性的要求来确定
2. 如果对数据一致性要求极高,可使用配置中心协调同步本地缓存
> 具体而言,当修改本地缓存时修改相应的配置, 当系统感知到配置发生变化时则去更新缓存
3. 本地缓存的自动更新功能

- 布隆过期器的缺点
存在误判率, 支持删除困难
原布隆过滤器应该是一串二进制,每一位是一个bit,无法支持删除,如果要支持删除的话,可以将bit改为byte(或者其他),在添加元素时将对应位全部+1,在删除元素时,对应元素全部减一(但是需要确定数据集中真的有这个数据,否则可能出现问题)
