---
title: 线程同步
category: 多线程
---

- 多线程没有同步可能会出现的问题
1. 竞态条件:
多个线程共同修改同一个变量,可能发生不可预测的结果
2. 死锁
3. 活锁
> 什么是活锁?可以理解为两人迎头而遇,然后礼让对方,导致又迎头而遇,又礼让,如此往复

- linux线程同步的方法
1. 互斥锁
2. 读写锁
3. 信号量
4. 条件变量
> 进程通信:
1. 管道
2. 消息队列
3. 共享内存
4. 信号量
5. Socket(跨主机)

- 如何应对高并发
1. 一锁二判三更新
2. redis搭集群等,载入redis中操作(更快)

- 针对某一商品10000的tps还是会顶不住,怎么办
在秒杀场景中,如果对于某个商品10000的库存,qps甚至更高,放mysql,redis中硬顶都顶不住的  

分段锁:
对于10000的库存,不放在一起(加一把锁),把它拆成100段,每段100个库存,对于每一段加锁,对于扣减库存的操作先走到某一段中(随机路由,hash算法),然后扣减该段的库存,如果该段库存不够,则去扣减下一段的库存(因为这个点可能导致后期反复重试,性能并不能到达预期)
> 分段锁在哪里有出现
ConcurrentHashMap, LongAddr

优化:
设分段锁,以及全局锁(库存放多点).  
先hash算法到某一段中扣减库存,如果库存不够尝试获取全局库存锁扣减库存.(兜底)  
定时调度任务将全局库存少量多次地迁移到分段库存中.

> 即是如此,还是不能保证绝对的谁快谁就抢到,比如用户a尝试获取5份库存,然后此时分段锁a,b,c,d各有2个库存,全局锁有4个库存,那么此时虽然总库存数为12,但是用户a依然抢不到
无奈,一致性换可用性 CAP

- wait()和sleep()的区别
1. wait()是Object类的方法,常常与notify(),notifyAll()配合使用;sleep()是Thread类提供的方法
2. wait()会释放锁,sleep()不会释放锁
3. sleep()常用于短暂时间内暂停线程执行,wait()常用于线程间交互与通信


