---
title: 操作系统中的IO
category: os
---

- IO分类
1. 标准IO(缓存IO)
在linux的缓存IO中,数据先从磁盘拷贝到内核空间的缓冲区(内核线程会定时写回磁盘),然后再从内核空间拷贝到用户空间.
优点:  
减少磁盘读写次数,(内核空间缓冲区有的话,直接从内核空间拿),提高效率  
一定程度上分离用户空间和内核空间,保护系统安全
缺点: 
来回拷贝,增大cpu以及内存的开销
2. 直接IO
跳过内核空间缓冲区,直接去磁盘中寻找数据
优点: 
可以解决缓存IO的缺点,无需在用户空间和内核空间来回拷贝数据
缺点:
无法利用到内核空间缓冲区,每次IO都要读磁盘,效率低  
需要在应用层自己实现缓存
3. mmap(内存映射)
一个可以让用户直接访问内存空间的机制.
优点:
减少拷贝次数.只需从磁盘拷贝一次,不用从内核空间拷贝到用户空间
缺点: 
虚拟内存增大. 超大文件时可能出现OOM

- 多个进程同时修改文件可以吗?
可以.  
当我们vim demo.txt时,实际上会在其同级目录下生成一个**demo.txt.swp**文件,直至我们保存时,才会将demo.txt.swp的内容拷贝到demo.txt中,删除demo.txt.swp.  
如果用户a正在修改demo.txt,然后用户b也来修改,用户读到的还是demo.txt的内容,如果用户b没保存就看不到用户b的修改(**隔离**),同时用户b也会生成一个**demo.txt.swo**文件..  
对,后面的用户依次会是.swo, .swn, .swm, .swl等..
对了,如果用户b开始修改后,用户a保存了自己的修改,用户b再保存时,会提示不一样了,是否还要保存,如果保存,则会直接覆盖了用户a的保存

- 讲一讲各种IO模型
1. 阻塞IO:
当应用请求接收数据时,会阻塞等待,直到数据到达内核空间中,然后将数据拷贝到用户空间缓冲区使用
2. 非阻塞IO:
当应用请求接收数据时,如果内核空间中还没有数据,不会等待,会返回错误码.否则将数据拷贝到用户空间使用
3. IO多路复用
以上两种对于每一个fd都是由一个线程去监听,而多路复用IO则使用一个线程去监听多个文件描述符,节省了资源  
4. 异步IO
在应用请求接收数据后,直到数据被拷贝到内核空间后又被拷贝到用户空间后才会通知应用IO完成  

- 零拷贝技术

||CPU拷贝|DMA拷贝|系统调用|上下文切换|
| --- | --- | --- | --- | --- |
|传统方法|2|2|read/write|4|
|内存映射|1|2|mmap/write|4|
|sendfile|1|2|sendfile|2|
|scatter/gather copy|0|2|sendfile|2|
|splice|0|2|splice|0|
